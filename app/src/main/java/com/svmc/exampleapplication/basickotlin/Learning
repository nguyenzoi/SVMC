#1 Project Setup - MVVM To-Do List App with Flow and Architecture Components

#2 Layouts & Room Entity
+ create layout main, item recycle view,
++ CoordinatorLayout
- là lớp mở rộng của ViewGroup giống với FrameLayout, thường sử dụng để thiết kế layout chính
- thêm compile 'com.android.support:design:26.1.0'
- thuộc tính app:layout_anchor chỉ ra phần tử view để neo
app: layout_anchorGravity kết hợp với Gravity botton|left|top|right

+ create dataclass, add annotation Parcelize
Parcelable: là một interface android cho phép đọc ghi kiểu dữ liệu vào/tù a byte array
-> giúp cải thiện thời gian chạy
-> cần đo time để biết rõ khi thêm và không thêm annotation này

#3 Navigation Component
is a collection of libraries, a plugin and tooling for unifying(hop nhat hoa) and simplifying (don gian hoa) android navigation
Benefits:
+ simplified setup for common navigation patterns
+ Handles backstack
+ Automates fragment transactions
+ Type safe argument passing
+ Handles transition animations
+ Simplified deep linking
+ Centralizes and visualizes navigation

- 3 major parts
+ Navigation graph
+ NavHostFragment
+ NavController

- Navigation UI
+ Options Menus
+ Botton Navigation
+ Navigation View
+ Navigation Drawer
+ ActionBar
+ Toolbar
+ Collapsing Toolbar

** dif normal args and safe args?
EXP: truyen kieu float -> get kieu int
 If you don't use Safe Args, you'll have to make extra sure that those manually stay in sync
  to ensure that your call to navigate() doesn't throw an exception at runtime
 . The arguments are just a nice extra on top of that.

** . Deep links are a way to jump into the middle of your app's navigation, whether that's
from an actual URL link or a pending intent from a notification.

** Difference between destination and  popUpto
+ Destination always push to stacks
+ popUpto pop all until meet the fragment. if PopUpToInclusive is true pop the fragment and push again
, else push new same fragment

#4 Room Dependency Injection
++ Suspend function
 is a function that could be started, paused, and resume.
+ they are only allowed to be called from a coroutine or another suspend function.
+ return only a single value
Using:
Xử dụng để tạm nhừng chỗ cho hàm khác
https://viblo.asia/p/hieu-ve-suspend-function-trong-kotlin-coroutines-RQqKLAnNZ7z

++ Annotation
+ @Retention
+ @Documented
+ @Target
+ @Repeatable
+ @MustBeDocumented

Khái niệm:
+ Dagger is a fully static, compile-time dependency injection framework for Java, Kotlin, and Android.
It is an adaptation of an earlier version created by Square and now maintained by Google.

Mục đính Dagger, Dagger-Hilt:
+ Quản lý các dependencies

Benefit Dagger:
+ Generating the AppContainer code (application graph) that you manually implemented
in the manual DI section.
+ Creating factories for the classes available in the application graph.
This is how dependencies are satisfied internally.
+ Deciding whether to reuse a dependency or create a new instance through the use of scopes.
+ Creating containers for specific flows as you did with the login flow in the previous
section using Dagger subcomponents. This improves your app's performance by releasing objects
in memory when they're no longer needed.

Cấu trúc của dagger

Modules: @module, @Provides
Component: @Component
Inject: @Inject

Hilt -Dagger2 vs Dagger?
Hilt vs Dagger2?
https://medium.com/huawei-developers/differences-between-dagger-and-hilt-3e347d24fb86
Does Hilt replace Dagger2?
+ No. Hilt still uses Dagger underneath the hood.
You could think of it as an opinionated Dagger extension for Android

#5 ListAdapter with View Binding

#6 Room Search
inline, noninline, crossinline function?
inline: annotation cho trihh bien dich chen luon than ham khi goi
noninline: Khong chen than ham goi qua overhead
crossinline: khonng cho phep return trong ham truyen vao
Uu diem inline:
+ Không cần phải gọi overhead
+ Tiết kiệm chi phí gọi hàm, thực hiện chương trình nhanh hơn
Nhược điểm:
+ Tốn bộ nhớ Stack nếu hàm chứa nhiều biến cục bộ
+ Tăng kích thước file class
+ Nếu dùng nhiều sẽ làm giảm tốc độ truy cập bộ đệm
Dùng khi nào:
+ Khi cần tối ưu hiệu suất, tăng tốc độ xử lý
+ Các hàm ngắn, được dùng nhiều lần
Trách dùng:
+ Khi code hàm dài, liên quan nhiều bên
+ Hàm khởi tạo (liên quan đến nhiều class)
+ Hàm trừu tượng

StateFlow: được mô tả là một flow đại diện cho trạng thái chỉ đọc với một giá trị dữ liệu có thể
cập nhật duy nhất phát ra các bản cập nhật giá trị cho bộ thu (flow collectors) của nó

StateFlow<T> interface chỉ cung cấp quyền truy cập giá trị.
MutabaleStateFlow<T> interface cung cấp khả năng sửa đổi giá trị.


#7 Combining multiple Flows
++ Collection vs Sequences vs flow
+ Collection: Handle all item then emit
+ Sequences: yield each item (xử lý đồng boọ): Thực hiện xong khối trong sequence mới thực hiện
khối khác
+ Flow: emit each item (xử lý bất đông bộ): Thực hiện song song với các khối khác

Flow:
+ là nguồn dữ liệu lạnh (cold streams) để thực hiên cần gọi collect function
+ chỉ có thể bị hủy khi gặp hàm suspend
https://viblo.asia/p/cung-hoc-kotlin-coroutine-phan-8-flow-part-1-of-3-bWrZnx695xw
Toán tử:
take, combine, flatmaplatest..
https://viblo.asia/p/cung-hoc-kotlin-coroutine-phan-9-flow-part-2-of-3-07LKXmX8ZV4
Toán tử đặc biệt:
onCompleate: handle after finish emit
catch: handle catch exception
https://viblo.asia/p/cung-hoc-kotlin-coroutine-phan-10-flow-part-3-of-3-aWj53G4o56m

#8 Saving Data with Jetpack DataStore
#9 Updating Checked Tasks
#10 Swipe-to-Delete & Undo
#11 Nav Args & SavedStateHandle
#12 Add/Edit Logic
#13 Delete-All-Completed Dialog
#14 Restoring the Fragment SearchView
